name: Stack PNGs from /source to /Web

on:
  push:
    paths:
      - 'source/**.png'
    branches:
      - main
  workflow_dispatch:

jobs:
  stack-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
       
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
       
      - name: Install Pillow
        run: pip install pillow
       
      - name: Stack consecutive images
        run: |
          python <<'PY'
          import os
          import re
          import sys
          from PIL import Image

          source_dir = "source"
          target_dir = "Web"

          os.makedirs(target_dir, exist_ok=True)

          # remove old tXX.png files (both v and h prefixed)
          for filename in os.listdir(target_dir):
              if filename.lower().endswith('.png'):
                  if (filename.lower().startswith('v') or filename.lower().startswith('h')) and filename[1:3].isdigit():
                      try:
                          os.remove(os.path.join(target_dir, filename))
                      except OSError:
                          pass

          # natural sort helper so s1, s2, s10 sort correctly
          def natural_key(s):
              return [int(part) if part.isdigit() else part.lower() for part in re.split(r'(\d+)', s)]

          # collect and separate source PNGs by prefix
          all_images = [f for f in os.listdir(source_dir) if f.lower().endswith(".png")]
          v_images = [f for f in all_images if f.lower().startswith('v')]
          h_images = [f for f in all_images if f.lower().startswith('h')]
          
          v_images.sort(key=natural_key)
          h_images.sort(key=natural_key)

          def process_images(images, prefix, stack_vertical):
              n = len(images)
              if n == 0:
                  return 0

              # Build target pairings according to your rules:
              # for i in 0..n-1:
              #   if i is even:  first = s[i],     second = s[i+1]
              #   if i is odd:   first = s[i+1],   second = s[i]
              # wrap indices with modulo n
              pairs = []
              for i in range(n):
                  if i % 2 == 0:
                      first = images[i]
                      second = images[(i + 1) % n]
                  else:
                      first = images[(i + 1) % n]
                      second = images[i]
                  pairs.append((first, second))

              # If number of pairs is odd, append a duplicate-first frame
              if len(pairs) % 2 == 1:
                  pairs.append((images[0], images[0]))

              # Create stacked images
              for idx, (first_name, second_name) in enumerate(pairs):
                  first_path = os.path.join(source_dir, first_name)
                  second_path = os.path.join(source_dir, second_name)

                  img_first = Image.open(first_path).convert("RGBA")
                  img_second = Image.open(second_path).convert("RGBA")

                  if img_first.size != img_second.size:
                      raise AssertionError(
                          f"Size mismatch: '{first_name}' is {img_first.size} but '{second_name}' is {img_second.size}."
                          " All source images must have identical dimensions."
                      )

                  if stack_vertical:
                      # Stack vertically: double the height
                      stacked = Image.new("RGBA", (img_first.width * 2, img_first.height))
                      stacked.paste(img_first, (0, 0))
                      stacked.paste(img_second, (img_first.width, 0))
                  else:
                      # Stack horizontally: double the width
                      stacked = Image.new("RGBA", (img_first.width, img_first.height * 2))
                      stacked.paste(img_first, (0, 0))
                      stacked.paste(img_second, (0, img_first.height))

                  t_name = f"{prefix}{str(idx + 1).zfill(2)}.png"
                  output_path = os.path.join(target_dir, t_name)
                  stacked.save(output_path)
                  print(f"Created {t_name}  <- {'left' if stack_vertical else 'top'}: {first_name}, {'right' if stack_vertical else 'bottom'}: {second_name}")

              return len(pairs)

          # Process v images (stack vertically - top and bottom)
          v_count = process_images(v_images, 'v', stack_vertical=False)
          if v_count > 0:
              print(f"Generated {v_count} v-images from {len(v_images)} source v-images")

          # Process h images (stack horizontally - side by side)
          h_count = process_images(h_images, 'h', stack_vertical=True)
          if h_count > 0:
              print(f"Generated {h_count} h-images from {len(h_images)} source h-images")

          if v_count == 0 and h_count == 0:
              print("No source images found in", source_dir)
              sys.exit(0)
          PY

      - name: Rotate horizontal images 90° CCW
        run: |
          python <<'PY'
          import os
          from PIL import Image

          web_dir = "Web"

          for filename in os.listdir(web_dir):
              if filename.lower().startswith('h') and filename.lower().endswith('.png'):
                  path = os.path.join(web_dir, filename)
                  with Image.open(path) as img:
                      rotated = img.rotate(90, expand=True)
                      rotated.save(path)
                      print(f"Rotated {filename} by 90° CCW")
          PY

      - name: List generated files
        run: |
          echo "Files in Web directory:"
          ls -la Web/ || echo "Web directory not found"
       
      - name: Commit and push stacked images
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add Web/
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update stacked images in /Web"
            git push origin main
          fi